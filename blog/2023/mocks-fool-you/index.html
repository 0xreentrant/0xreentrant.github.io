<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title>Don't let mocks in your protocol tests fool you | reentrant</title> <meta name="author" content="reentrant "> <meta name="description" content="The biggest threat to developing a protocol is the mental model"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="https://unpkg.com/bootstrap-table@1.22.1/dist/bootstrap-table.min.css"> <link rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons"> <link rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?19f3075a2d19613090fe9e16b564e1fe" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%E2%9A%9B%EF%B8%8F&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://0xreentrant.github.io/blog/2023/mocks-fool-you/"> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/">reentrant</a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about</a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">blog<span class="sr-only">(current)</span></a> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5"> <div class="post"> <header class="post-header"> <h1 class="post-title">Don't let mocks in your protocol tests fool you</h1> <p class="post-meta">March 20, 2023</p> <p class="post-tags"> <a href="/blog/2023"> <i class="fas fa-calendar fa-sm"></i> 2023 </a> </p> </header> <article class="post-content"> <div id="table-of-contents"> <ul id="toc" class="section-nav"> <li class="toc-entry toc-h1"> <a href="#dont-let-mocks-in-your-protocol-tests-fool-you">Don’t let mocks in your protocol tests fool you</a> <ul> <li class="toc-entry toc-h2"><a href="#our-case">Our case</a></li> <li class="toc-entry toc-h2"> <a href="#mocks-have-tradeoffs">Mocks have tradeoffs</a> <ul> <li class="toc-entry toc-h3"><a href="#but-what-are-the-consequences">But what are the consequences?</a></li> </ul> </li> <li class="toc-entry toc-h2"><a href="#how-can-i-ensure-our-mocks-are-correct">How can I ensure our mocks are correct?</a></li> <li class="toc-entry toc-h2"> <a href="#what-do-these-possibilities-look-like">What do these possibilities look like?</a> <ul> <li class="toc-entry toc-h3"><a href="#smoke-tests">Smoke tests</a></li> <li class="toc-entry toc-h3"><a href="#manual-testing-on-a-testnet">Manual testing on a testnet</a></li> <li class="toc-entry toc-h3"><a href="#forking-tests">Forking tests</a></li> <li class="toc-entry toc-h3"><a href="#live-integration-tests">Live Integration Tests</a></li> </ul> </li> <li class="toc-entry toc-h2"><a href="#conclusion">Conclusion</a></li> </ul> </li> </ul> </div> <hr> <div id="markdown-content"> <h1 id="dont-let-mocks-in-your-protocol-tests-fool-you">Don’t let mocks in your protocol tests fool you</h1> <blockquote> <p>Note: This article was written for web3 protocol developers. Security researchers will also get a little glimpse into techniques for testing protocols.</p> </blockquote> <p><em>Mocking expensive, slow, or complex-to-set-up components is a great way to make testing faster, cheaper, and simpler to leverage. What can happen though, is that the expectations of the mock can diverge from the expectations of the real-world object. When that happens, you can be oblivious to the fact your codebase does not, in fact, work, green checkmarks be damned.</em></p> <p><em>The biggest threat to developing a protocol is the mental model of the protocol within the mind of the developer. A flawed mental model happens from numerous sources, but today we’ll focus on a single one: the feeling of security that comes with passing tests</em></p> <blockquote> <p>Note: I’m using the definition of “mock” to be along the lines of how Martin Fowler uses it here: https://martinfowler.com/articles/mocksArentStubs.html</p> </blockquote> <p><strong>TL;DR</strong> If you want to skip to what kind of things you can do to prevent mocks from fooling you, jump to <a href="#how-can-I-ensure-our-mocks-are-correct">How can I ensure our mocks are correct?</a></p> <h2 id="our-case">Our case</h2> <p>Imagine getting green checkmarks on all your tests. You’ve gone ahead and built a suite to exercise the entire happy path of your codebase, and even some edge cases to boot. And even better: every test passed. It’s a good time to grab a beer or wine and take a little break, because next you’re going to discover something unsavory when you try to run through the deployed example.</p> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/all-tests-green-480.webp"></source> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/all-tests-green-800.webp"></source> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/all-tests-green-1400.webp"></source> <img src="/assets/img/all-tests-green.png" class="img-fluid" width="auto" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <blockquote> <p>Note: Before you hire a firm or to audit your code, do make sure to fully deploy your code to a testnet with all 3rd-party contracts and features available. For example: testing cross-chain protocols</p> </blockquote> <p>Cutting to the chase, you’re going to “Oh no, what’s wrong, I coded this <em>perfectly</em> - all the tests pass!” And you’re going to feel so right, because your mental model was impeccable and your tests reflected that… <em>but your mocks fooled you</em>. Actually, it’s just a case of a “<a href="https://en.wikipedia.org/wiki/False_positives_and_false_negatives" rel="external nofollow noopener" target="_blank">false positive</a>” (lest we lose our last shred of sanity and <a href="https://psychcentral.com/health/why-do-we-anthropomorphize" rel="external nofollow noopener" target="_blank">anthropomorphize</a> our code). Green checks that don’t give confidence are the antithesis of any testing methodology, so let’s break down what to keep in mind.</p> <h2 id="mocks-have-tradeoffs">Mocks have tradeoffs</h2> <p>When we use mocks, we’re taking a stance. The two main ones I hear and have held are:</p> <ol> <li>Our dependencies are too expensive, slow, or complex to spin up each time we test (<em>fair!</em>)</li> <li>We want our tests to run quickly, and we can’t wait for each test iteration to fully pass or well lose out on momentum (<em>fair!</em>)</li> </ol> <h3 id="but-what-are-the-consequences">But what are the consequences?</h3> <p>These tradeoffs, again, are fair to make when the stakes are low, like:</p> <ul> <li>When you’re building the protocol, pre-launch</li> <li>When you’re adding to an existing protocol and need the flexibility to refactor highly-coupled parts of a system</li> <li>When you’re exploring how to implement a new system</li> </ul> <p>Etc.</p> <p>But in the case of running a web3, immutable, smart-contract-based, financial protocol the stakes are high. As protocol developers in a hyper-competitive environment with close to zero consequences for exploitation by psuedo-anonymous actors that include globally-sanctioned blackhats, more care must be taken before accepting real people’s assets. I’ll let our industry’s favorite rug-pull <a href="https://rekt.news/stake-rekt/" rel="external nofollow noopener" target="_blank">journalist</a> say it best:</p> <p>They say the house always wins. Not in crypto.</p> <h2 id="how-can-i-ensure-our-mocks-are-correct">How can I ensure our mocks are correct?</h2> <p>“But reentrant, we read the documentation front-to-back and everything is working just like they said!”</p> <p>I 100% get it: you’ve put in the work.</p> <p>But, what if:</p> <ul> <li>The documentation is wrong</li> <li>The implementation has changed</li> <li>You used the wrong flag for a key function while trying to get that last PR in at 3am Saturday morning</li> </ul> <p>Then things break.</p> <p>What do you do? Add <em>at least</em> one more step, especially before deploying your new protocol.</p> <ol> <li>Create “smoke-tests” - as in short, typically disposable scripts that call major 3rd-party components the same as the mocks would be called.</li> <li>Deploy on a fully-functional testnet and run manual tests for all major features.</li> <li>Build “forking tests” that fork a live network locally and test against it. Some dependencies may not work if they are off-chain.</li> <li>Build integration tests for all major features, deploy on a fully-functional testnet, and test against it.</li> </ol> <p>&lt; decision tree for determinnig when mocks fail &gt;</p> <h2 id="what-do-these-possibilities-look-like">What do these possibilities look like?</h2> <p>There’s nothing like a real environment to expose the brittleness of a test suite’s assumptions. While it might seem unnecessary “because it’s there in the code,” the unique case of web3 warrants the extra paranoia.</p> <h3 id="smoke-tests">Smoke tests</h3> <p>This one makes sense when your contracts interface with 3rd-party code. Each feature that touches a 3rd-party contract is either triggered in a script or run manually. If the feature breaks, but your mocking tests were all passing, there is an issue with your mock.</p> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/smoke-tests-480.webp"></source> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/smoke-tests-800.webp"></source> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/smoke-tests-1400.webp"></source> <img src="/assets/img/smoke-tests.png" class="img-fluid" width="auto" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <p>For example: imagine you are a protocol developer lead that wants to test that each feature that is mocked works. You would:</p> <ol> <li>Identify all the features that touch 3rd-party code.</li> <li>Write a script to exercise the 3rd-party contract code for each relevant feature, according to how you expect the API of that code to work.</li> <li>Run your script.</li> <li>Make a note if something broke, and how it broke</li> </ol> <p>You will find that increased logging through events or console logs will be useful when creating your scripts.</p> <p>We won’t go much deeper on the subject of smoke tests in web3, but here’s a great article for learning more about smoke tests: https://www.edureka.co/blog/what-is-smoke-testing/</p> <h3 id="manual-testing-on-a-testnet">Manual testing on a testnet</h3> <p>This one is pretty obvious in operation. The goal here is to make sure every feature that interfaces with 3rd-party components has been run, along with some edge-cases that have been identified. That way you are exercising whatever assumptions your code is making about the interface of code you don’t control.</p> <p>The advantage to running these on an existing testnet is that any off-chain systems your preferred 3rd-party system uses will be more or less accessible. A downside would be the necessity of amassing gas tokens for the respective testnet.</p> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/manual-tests-480.webp"></source> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/manual-tests-800.webp"></source> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/manual-tests-1400.webp"></source> <img src="/assets/img/manual-tests.png" class="img-fluid" width="auto" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <p>Similarly to running smoke tests, the point is to get an actual look at whether any assumptions encoded in the codebase, and your mocks, match the real-world requirements of any 3rd-party component.</p> <p>Doing this yourself:</p> <ol> <li>Identify all the features that touch 3rd-party code.</li> <li>Perform all the operations in your app to exercise the 3rd-party contract code for each relevant feature, according to how you expect the API of that code to work.</li> <li>Make a note if something broke, and how it broke</li> </ol> <p>If any of your mocking tests passed, but manual testing fails where your tests had mocks, then that’s an unmistakable sign something is broken in your codebase <em>and</em> tests.</p> <h3 id="forking-tests">Forking tests</h3> <p>When there is no need to monitor the results of any off-chain systems, you can fork any live chain and run a version of it locally for more control and execution speed. This also is advantageous for the off-chance that your 3rd-party of choice decides not to run a version on a testnet.</p> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/forking-tests-480.webp"></source> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/forking-tests-800.webp"></source> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/forking-tests-1400.webp"></source> <img src="/assets/img/forking-tests.png" class="img-fluid" width="auto" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <p>Unlike the smoke tests and the manual tests, we are back to writing automated tests. We can use our existing testing suites, with the modification that now any mocked calls will instead call actual contracts hosted on the forked testnet. That way any assumptions that mocks encode will be instead tested against actual code.</p> <p>A disadvantage of this approach is that the tests themselves will likely take longer to run each cycle compared to the mocking tests. However, compared to smoke tests and manual testing, you’ll get the increased coverage and repeatability of automated testing along with the better assurance of correctness.</p> <h3 id="live-integration-tests">Live Integration Tests</h3> <p>The most intensive version of testing that would shake out any assumptions about 3rd-party interfaces in your codebase would be integration tests on a live testnet. All components are deployed to the testnet, mocks in tests are replaced with calls to actual on-chain resources, all tests run against the live testnet, and off-chain resources are available to monitor. You will need any testnet gas tokens for every run of the test suite.</p> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/integration-tests-480.webp"></source> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/integration-tests-800.webp"></source> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/integration-tests-1400.webp"></source> <img src="/assets/img/integration-tests.png" class="img-fluid" width="auto" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <p>Every test will exercise live code as close to the final, real-world software environment possible. Any tests that fail here will give a lot of information about assumptions encoded in your codebase. Because there will be subtle differences between a local fork and an actual live chain, and the cost of running the test suite (in time and testnet gas) it will be helpful to monitor the results of the tests with other tools such as chain explorers like <a href="https://tenderly.co/" rel="external nofollow noopener" target="_blank">Tenderly</a> for delving into any edge cases that the other techniques did not uncover.</p> <h2 id="conclusion">Conclusion</h2> <p>We can see that mocks are helpful, but they have tradeoffs. To counter the possibility that mocks will give us false-positives, we can increase the assurances by running tests against actual 3rd-party code.</p> <p>In web3, it is imperative that all precautions are made to ensure real money isn’t lost to thefts or mishandling of digital currency. Test more, test often, and test comprehensively.</p> </div> </article> </div> </div> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@4/imagesloaded.pkgd.min.js"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.8/dist/medium-zoom.min.js" integrity="sha256-7PhEpEWEW0XXQ0k6kQrPKwuoIomz8R8IYyuU1Qew4P8=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?7b30caa5023af4af8408a472dc4e1ebb"></script> <script defer src="https://unpkg.com/bootstrap-table@1.22.1/dist/bootstrap-table.min.js"></script> <script src="/assets/js/no_defer.js?d633890033921b33e0ceb13d22340a9c"></script> <script defer src="/assets/js/common.js?acdb9690d7641b2f8d40529018c71a01"></script> <script defer src="/assets/js/copy_code.js?c9d9dd48933de3831b3ee5ec9c209cac" type="text/javascript"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>