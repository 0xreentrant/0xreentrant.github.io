<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://0xreentrant.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://0xreentrant.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2024-05-01T22:17:22+00:00</updated><id>https://0xreentrant.github.io/feed.xml</id><title type="html">reentrant</title><subtitle>security engineer, web3 protocols, and blockchain </subtitle><entry><title type="html">Price Oracle Attacks Will Get You Rekt, P.1</title><link href="https://0xreentrant.github.io/blog/2024/price-oracle-attacks-will-get-you-rekt-p1/" rel="alternate" type="text/html" title="Price Oracle Attacks Will Get You Rekt, P.1"/><published>2024-05-01T00:00:00+00:00</published><updated>2024-05-01T00:00:00+00:00</updated><id>https://0xreentrant.github.io/blog/2024/price-oracle-attacks-will-get-you-rekt-p1</id><content type="html" xml:base="https://0xreentrant.github.io/blog/2024/price-oracle-attacks-will-get-you-rekt-p1/"><![CDATA[<blockquote> <p><strong>NOTE:</strong> This article assumes the reader has experience with DeFi products and smart contract development, but little substantial security or auditing experience.</p> </blockquote> <p>Today we’re going to explore Price Oracle Attacks. In the proceeding exploration, take time to follow the included links for more background information. I’d like to make sure you can follow along with me.</p> <h1 id="price-oracle-attacks-will-get-you-rekt">Price Oracle Attacks Will Get You Rekt</h1> <p>DeFi has seen, in real money, over $8,000,000,000, lost in hacks. You’ve probably been a victim. If you’ve released anything within the DeFi ecosystem, you might have had it happen to you. During this series, we’ll explain the one technique used to perform these hacks. In this part, we’ll be looking specifically at a noteworthy hack on Inverse Finance.</p> <h2 id="a-common-tool-and-a-common-attack">A Common Tool and a Common Attack</h2> <p>Inverse Finance’s Frontier protocol was <a href="https://rekt.news/inverse-finance-rekt/">hacked on April 2nd, 2022 for $15.6m</a> using a <a href="https://ethereum.org/en/developers/docs/oracles/">Price Oracle</a> attack.</p> <p>Price oracle attacks are among the top 10 types of hacks <a href="https://medium.com/immunefi/the-top-10-most-common-vulnerabilities-in-web3-bf7a921d489f#:~:text=V03%3A2023%20Oracle/Price%20Manipulation">according to Immunifi</a>. To underscore how high the cost is, consider that the <a href="https://rekt.news/mango-markets-rekt/">two</a> <a href="https://rekt.news/cream-rekt-2/">costliest</a> price oracle attacks account for $245,000,000 lost in DeFi alone. Why this keeps happening is that getting useful price feeds in DeFi is not a solved problem, and so developers face trade-offs in providing useful price feeds when building protocols. Popular CeFi exchange Coinbase <a href="https://www.coinbase.com/blog/introducing-the-coinbase-price-oracle">judges the problem clearly</a>:</p> <blockquote> <p>There are two main approaches to making asset prices available for DeFi: publishing signed price data from an off-chain source like an exchange, or using prices from algorithmic decentralized exchanges (DEXes) such as Uniswap or Kyber.</p> <p>Unfortunately, both suffer from major problems. Using data from an off-chain source requires trusting the publisher to post correct prices and keep the signing key safe — the latter historically has proven to be a difficult problem, especially when stakes are high. Similarly, relying on DEX-generated on-chain feeds exposes protocols to various novel attack vectors yet to be fully explored.</p> </blockquote> <p>Oracles rely on data that might require off-chain trust. Or reliance on potentially faulty on-chain calculations from 3rd-parties. Simply put, a bad price oracle means a bad financial calculation - anathema to the whole concept of accounting.</p> <h3 id="what-makes-a-price-oracle-attack">What makes a Price Oracle attack</h3> <p>It’s leveraging the tradeoffs an oracle chooses. For example, an oracle might need to get the most up-to-date price, but because their prices are determined strictly by reserve ratios, the price is liable to be manipulated by a motivated attacker when the pool liquidity is sufficiently low. As an opposing example, if an oracle is configured to smooth out volatility in prices by taking averages across a long time span, then prices might not reflect true market value. To find a middle ground, some oracles take an average of multiple values. As this first Price Oracle attack is explained, it’ll become clear that vulnerabilities can still emerge.</p> <h2 id="price-oracle-attacks-by-example">Price Oracle Attacks by Example</h2> <p>Price Oracle attacks had <a href="https://defillama.com/hacks">been done before</a> in DeFi. It wouldn’t even be the last time our protocol in question would be hacked. But, in spite of millions on the line, it happened, all because Inverse Finance missed a vulnerability in how their assets were priced.</p> <p>To explain, we’ll describe the vulnerability, then explore how it all came together.</p> <h3 id="inverse-finance---a-calculated-attack-with-a-small-pool">Inverse Finance - a Calculated Attack with a Small Pool</h3> <p>Here’s the bottom line for the Inverse hack. As <a href="https://www.coindesk.com/tech/2022/04/02/defi-lender-inverse-finance-exploited-for-156-million/">reported by Coindesk</a>:</p> <blockquote> <p>According to blockchain security firm <a href="https://twitter.com/peckshield/status/1510232640338608131">PeckShield</a>, the Inverse attacker took advantage of a vulnerability in a <a href="https://andrecronje.medium.com/keep3r-v2-oracles-8895f107561b">Keep3r price oracle</a> Inverse uses to track token prices. The attacker tricked the oracle into thinking that the price of Inverse’s INV token was extraordinarily high, and then took out multimillion-dollar loans on Anchor using the inflated INV as collateral.</p> </blockquote> <p>Specifically:</p> <ol> <li>The price of the INV token came from the INV/WETH pool on SushiSwap, which forked the <a href="https://docs.uniswap.org/contracts/v2/concepts/core-concepts/pools">Uniswap v2 Pool</a>. This pool provided a price oracle that used <a href="https://docs.uniswap.org/contracts/v2/concepts/core-concepts/oracles">time-weighted average prices</a> (TWAP) available to 3rd-parties. This oracle’s price was safe from manipulation, <a href="https://docs.uniswap.org/contracts/v2/concepts/core-concepts/oracles#:~:text=the%20cost%20of%20manipulation%20increases%20(approx.%20linear)%20with%20liquidity%20on%20Uniswap%2C%20as%20well%20as%20(approx.%20linear)%20with%20the%20length%20of%20time%20over%20which%20you%20average">as long as there was enough liquidity</a> in a pool to make the attack too expensive.</li> <li>The INV/ETH pool did not have enough liquidity to defend against a price manipulation attack.</li> <li>Inverse Finance’s lending pools used <a href="https://keep3r.network/">the Keep3r network</a> to retrieve the prices from the SushiSwap. This oracle would only use the most up-to-date prices as long as the difference in time between the SushiSwap pool last record and Keep3r’s last record <a href="https://inspexco.medium.com/inverse-finances-incident-analysis-inv-price-manipulation-b15c2e917888#:~:text=2%E2%80%99s%20wallet.-,Root%20Cause%20Analysis,-The%20core%20oracle">were not equal</a>.</li> <li>The attacker made sure the time difference between both records were equal.</li> </ol> <p>Despite the obstacles put in place by Uniswap’s V2 TWAP design, cloned by SushiSwap, as well as the layer provided by Keep3r’s oracle, INV was price manipulated - the oracles in place could not defend against the attack.</p> <p>Let’s run through the key factors of the attack scenario before we discuss the implementation details. That way we’ll be able to see why each piece of the vulnerability made the attack possible.</p> <h3 id="the-price-manipulation---leverage">The Price Manipulation - Leverage</h3> <p>Recall that the Uniswap V2 AMM uses a<a href="https://docs.uniswap.org/contracts/v2/concepts/protocol-overview/how-uniswap-works#:~:text=Pairs%20act%20as%20automated%20market%20makers"> constant product formula</a> to price its assets. In this case, when a pool has limited liquidity, the constant product formula provides prices with much greater slippage. From the <a href="https://docs.uniswap.org/contracts/v2/concepts/protocol-overview/how-uniswap-works#:~:text=This%20formula%20has%20the%20desirable%20property%20that%20larger%20trades%20(relative%20to%20reserves)%20execute%20at%20exponentially%20worse%20rates%20than%20smaller%20ones.">Uniswap docs</a>:</p> <blockquote> <p>This formula has the desirable property that larger trades (relative to reserves) execute at exponentially worse rates than smaller ones.</p> </blockquote> <p>For the low-liquidity WETH/INV pool, the INV received after the swap removed so much liquidity that its price in that pool skyrocketed. Any protocols using the price of INV according to that pool would now report this manipulated price nearly 50x higher than originally.</p> <p>Study the figure below:</p> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/inverse_attacker_manipulation-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/inverse_attacker_manipulation-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/inverse_attacker_manipulation-1400.webp"/> <img src="/assets/img/inverse_attacker_manipulation.png" class="img-fluid" width="auto" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <p>In the first step, <a href="https://app.blocksec.com/explorer/tx/eth/0x20a6dcff06a791a7f8be9f423053ce8caee3f9eecc31df32445fc98d4ccd8365?line=9">a low liquidity pool’s was targeted (WETH/INV)</a>, and was manipulated by swapping 300 WETH. This caused the price of INV to jump from 0.106 WETH (about $366) to 5.966 WETH (about $20,583), <a href="https://www.oklink.com/academy/en/2022/07/12/hot-inverse-finance-loses-over-15m-in-oracle-manipulation#:~:text=INV%20price%20from-,0.106%20WETH%20(about%20%24366)%20to%205.966%20WETH%20(about%20%2420%2C583),-in%20the%20WETH">according to analytics firm OKLINK’s report</a></p> <p>The fund flow highlighted area shown below is the key price manipulation.</p> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/inverse_attacker_swap_flow-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/inverse_attacker_swap_flow-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/inverse_attacker_swap_flow-1400.webp"/> <img src="/assets/img/inverse_attacker_swap_flow.png" class="img-fluid" width="auto" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <h4 id="small-pool-big-pressure">Small Pool Big Pressure</h4> <p>The big question is then, “Why is INV/WETH the target when there were other pools around?” In fact, our attacker did swap for vastly more INV using the INV/DOLA pool. However, when we inspect the Inverse Finance lending contract on Etherscan we can see it uses the INV/WETH pool TWAP to determine an account’s liquidity:</p> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/keep3r_oracle_pool-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/keep3r_oracle_pool-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/keep3r_oracle_pool-1400.webp"/> <img src="/assets/img/keep3r_oracle_pool.png" class="img-fluid" width="auto" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <p>The attacker knew that loan withdrawals using INV were priced internally by checking the INV/WETH pool prices, and that the INV/WETH pool had dangerously low liquidity.</p> <p>When it comes to price oracle attacks, <a href="https://chain.link/education-hub/market-manipulation-vs-oracle-exploits#:~:text=Oracle%20Exploit%20as%20a%20Result%20of%20Poor%20Market%20Coverage">Chainlink describes this instance best</a>:</p> <blockquote> <p>Poor market coverage can lead to oracles misreporting the price of an asset. Relying on only a subset of all trading environments makes them vulnerable to an oracle exploit if that subset is manipulated, even when the majority of trading environments and the market-wide price remain unaffected.</p> <p>For example, if an asset is traded across five exchanges and 85% of trading volume takes place on two of those exchanges, relying on the other three low-liquidity exchanges for price inputs would give the oracle poor market coverage. If a malicious actor manipulated the price on those three low-liquidity exchanges, then the oracle would report a price that differs from the actual market-wide price, leading to possible exploits.</p> </blockquote> <p>Inverse Finance’s oracles had wildly poor market coverage. We’ll see that ultimately only a single market was considered.</p> <h3 id="exploiting-the-weak-oracle">Exploiting the Weak Oracle</h3> <p><a href="https://app.blocksec.com/explorer/tx/eth/0x600373f67521324c8068cfd025f121a0843d57ec813411661b07edc5ff781842">For the first block of the attack, the price of INV has been manipulated near 50x higher</a>. What happens in the next block is shown in the diagram below:</p> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/inverse_attacker_theft-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/inverse_attacker_theft-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/inverse_attacker_theft-1400.webp"/> <img src="/assets/img/inverse_attacker_theft.png" class="img-fluid" width="auto" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <p>Since Sushi’s pools use the Uniswap V2 TWAP, the attacker must wait until the next block to ensure the manipulated price becomes the pool’s actual price. After manually forcing the pool to do so with <a href="https://github.com/Uniswap/v2-core/blob/ee547b17853e71ed4e0101ccfd52e70d5acded58/contracts/UniswapV2Pair.sol#L197-L200">sync</a>, the attacker takes his profits by depositing their INV and withdrawing all the funds from Inverse’s lending pools, netting themselves roughly $15.6 million in stolen funds.</p> <h2 id="the-missing-link---mev">The missing link - MEV</h2> <p>If you’ve been reading and wondering, “How did this guy get away with the attack without be arbitraged to oblivion?” I won’t be <a href="https://twitter.com/bertcmiller/status/1510284763332071427">exploring the details</a> here but the high level summary is this:</p> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/inverse_attacker_spam-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/inverse_attacker_spam-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/inverse_attacker_spam-1400.webp"/> <img src="/assets/img/inverse_attacker_spam.png" class="img-fluid" width="auto" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <p>The attacker knows that MEV bots and arbitrageurs are waiting for price discrepancies. To protect against their manipulation getting arbitraged they opted to hide their transaction by directly sending it as a bundle using Flashbots.</p> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/inverse_attacker_bundle-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/inverse_attacker_bundle-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/inverse_attacker_bundle-1400.webp"/> <img src="/assets/img/inverse_attacker_bundle.png" class="img-fluid" width="auto" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <h2 id="lessons-learned">Lessons Learned</h2> <p>Let’s walk in the shoes of the devs and roleplay them in a room, the second after the incident.</p> <p>“Why could the attacker do this?” “What assumptions did they break wide open?” “How can we protect ourselves next time?”</p> <h3 id="poor-choices-and-missed-chances">Poor choices and missed chances</h3> <p>Let’s look at the actual oracles in play for this Price Oracle attack. To be clear, the oracles themselves are battle-tested across a wide range of use-cases. It was how they were utilized and the conditions around them that created the vulnerability.</p> <p>There has been some hand-waving used to simplify the explanation: the Keep3r oracle was designed to use multiple price feeds, and not just the one SushiSwap pool we described in the attack. In fact, the oracle was configure to query both Uniswap and SushiSwap INV/WETH pools for prices.</p> <p>How is that true, yet still our attacker still exploits the protocol?</p> <h4 id="sushiswap---the-low-liquidity-pool-danger">SushiSwap - the low-liquidity pool danger</h4> <p>It all begins with the price manipulation on the low-liquidity INV/WETH pool. By leaning on this pool for such a critical function as computing prices of lending pool, the protocol opened the door for a motivated attacker to control how much they could withdraw from Inverse, in bad faith. A single big trade, and the price moves dramatically.</p> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/amm-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/amm-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/amm-1400.webp"/> <img src="/assets/img/amm.png" class="img-fluid" width="auto" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <h4 id="keep3r-oracle-design---unused-oracles">Keep3r Oracle Design - Unused Oracles</h4> <p>In our scenario, Inverse used a <a href="https://github.com/keep3r-network/keep3r.network/blob/a6897007db6e656e0e310ed7ee4ad42904fe2794/contracts/Keep3rV2OracleFactory.sol#L23C10-L23C24">Keep3r V2 Oracle</a> as the final say in their price feed strategy. In front of that were feeds from a couple of INV/WETH pools as we’ll see.</p> <p><a href="https://app.blocksec.com/explorer/tx/eth/0x20a6dcff06a791a7f8be9f423053ce8caee3f9eecc31df32445fc98d4ccd8365?line=20&amp;debugLine=20">Looking into the transaction at the time of the attack</a>, we can see there are two feeds, and each feed’s pair ends up being:</p> <ol> <li><a href="https://etherscan.io/address/0x73E02EAAb68a41Ea63bdae9Dbd4b7678827B2352#readContract">Uniswap INV/ETH</a></li> <li><a href="https://etherscan.io/address/0x328dFd0139e26cB0FEF7B0742B49b0fe4325F821#readContract">SushiSwap INV/ETH</a></li> </ol> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/price_feeds-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/price_feeds-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/price_feeds-1400.webp"/> <img src="/assets/img/price_feeds.png" class="img-fluid" width="auto" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <p>We’d imagine this to to be helpful in the protocol’s defense, if they both contributed to protecting the INV price. That that is not the case. We’ll take note of this while thinking through a key mechanism in the oracle: how Keep3r’s TWAP prices are updated.</p> <h4 id="keep3r-twap---tradeoffs">Keep3r TWAP - Tradeoffs</h4> <blockquote> <p>NOTE: Keep3r V2 oracles use the same interface as <a href="https://docs.uniquote.finance/">Keep3r V1 oracles</a></p> </blockquote> <p>There are two major considerations when it comes to price feeds: Freshness and Security. For the Keep3r V2 oracle, <a href="https://docs.uniquote.finance/#price-feeds">there are two functions that correspond to either consideration:</a></p> <ul> <li>Freshness: <code class="language-plaintext highlighter-rouge">current()</code></li> </ul> <pre><code class="language-solidity">// returns the amount out corresponding to the amount in for a given token using the moving average over the time
function current(address tokenIn, uint amountIn, address tokenOut) external view returns (uint amountOut)
</code></pre> <p>This generates a simple TWAP using the difference between the actual pool’s TWAP and the last price records by the pool and Keep3r oracle. Essentially:</p> \[\text{amountOut} = \text{amountIn} \times \frac{\text{pool.price0CumulativeLast} - \text{lastObservation.price0Cumulative}}{\text{pool.lastCumulativePriceTimestamp} - \text{observation.lastObservationTimestamp}}\] <ul> <li>Security: <code class="language-plaintext highlighter-rouge">quote()</code></li> </ul> <pre><code class="language-solidity">// returns the amount out corresponding to the amount in for a given token using the moving average over the time taking granularity samples
function quote(address tokenIn, uint amountIn, address tokenOut, uint granularity) external view returns (uint amountOut)
</code></pre> <p>This second function creates its own TWAP by averaging the accumulated price observations itself. It supports an arbitrary “lookback” window (<code class="language-plaintext highlighter-rouge">granularity</code>), enabling callers to adjust their TWAP according to the desired level of volatility.</p> <p>Outlining the concept is the averaging logic:</p> <pre><code class="language-solidity">for (; i &lt; _length; i++) {
    nextIndex = i+1;
    currentObservation = observations[i];
    nextObservation = observations[nextIndex];
    priceAverageCumulative += _computeAmountOut(
        currentObservation.price0Cumulative,
        nextObservation.price0Cumulative,
        nextObservation.timestamp - currentObservation.timestamp, amountIn);
}
</code></pre> <p>This looks like the function one would like to use in the case of a price manipulation attack. This is not the case for Inverse Finance’s lending platform, and <code class="language-plaintext highlighter-rouge">current()</code> is used instead.</p> <p>Security is traded for Freshness. What ends up aiding the attacker is that Freshness allows the extreme spike in the manipulated price to affect Inverse’s lending rates.</p> <h4 id="keep3rs-freshness-function---a-volatility-sieve">Keep3r’s Freshness function - a volatility sieve</h4> <p><code class="language-plaintext highlighter-rouge">current()</code> <a href="https://github.com/keep3r-network/keep3r.network/blob/a6897007db6e656e0e310ed7ee4ad42904fe2794/contracts/Keep3rV2OracleFactory.sol#L90-L111">samples a single observation and computes the latest data from the pool TWAP</a>. For the purpose of freshness this is essential.</p> <pre><code class="language-solidity">uint price0Cumulative = IUniswapV2Pair(pair).price0CumulativeLast() * e10 / Q112;

// later, compute the price...

amountOut = _computeAmountOut(_observation.price0Cumulative, price0Cumulative, timeElapsed, amountIn);
</code></pre> <p>However, in the case that a pool’s price is manipulated artificially, that manipulated price will pass through to the oracle’s caller with little change compared to a more robust sampling of market prices.</p> <p>Worse, any defense <code class="language-plaintext highlighter-rouge">current()</code> provided against volatility through Keep3r observations is nullified by a vulnerability to stale observations.</p> <h4 id="keep3r-vulnerability---computing-with-canceled-terms">Keep3r Vulnerability - computing with canceled terms</h4> <p>The <a href="https://github.com/keep3r-network/keep3r.network/blob/a6897007db6e656e0e310ed7ee4ad42904fe2794/contracts/Keep3rV2OracleFactory.sol#L86-L88">actual computation to generate the price data</a> is this:</p> <pre><code class="language-solidity">amountOut = amountIn * (end - start) / e10 / elapsed;
</code></pre> <p>With the parameters used in the call to <code class="language-plaintext highlighter-rouge">_computeAmountOut</code> in <code class="language-plaintext highlighter-rouge">current()</code> we can see that expanded to:</p> \[\text{amountOut} = \text{amountIn} \times \frac{\text{pool.price0CumulativeLast} - \text{lastObservation.price0Cumulative}}{\text{pool.lastCumulativePriceTimestamp} - \text{observation.lastObservationTimestamp}}\] <p>If we expand the values in the equation, <a href="https://inspexco.medium.com/inverse-finances-incident-analysis-inv-price-manipulation-b15c2e917888#:~:text=When%20putting%20every%20parameter%20into%20the%20calculation%20of%20_computeAmountOut()%20function">then cancel like terms</a>, the resulting equation becomes:</p> \[\text{amountOut} = \text{amountIn} \times \text{pool.price0CumulativeLast}\] <p>Any defenses provided by Keep3r’s TWAP were disabled completely.</p> <h3 id="aftermath">Aftermath</h3> <p>In all, these vulnerabilities were missed chances to use a more robust source of fair market value with a more secure TWAP. $15 million was lost by Inverse and the lending pools were frozen The Frontier protocol was shut down and replaced with a new one. Since, inverse has been making <a href="">regular payments to compensate affected users</a>.</p> <h2 id="what-to-ask-for-next-time">What to ask for next time</h2> <p>In Part II of this series, we’ll examine more deeply the questions security-minded developers and auditors can ask while encountering price oracles.</p> <p>What kind of questions can help uncover this kind of flaw?</p> <ul> <li>Is the time window on the TWAP wide enough to handle the expected volatility?</li> <li>Could the oracle be getting data from a single, thinly-traded pool?</li> <li>Is there sufficient market coverage to be sure the prices reflect fair market value?</li> <li>How many price feeds would be necessary to make a price manipulation attack prohibitively expensive?</li> <li>Is the chain we use more or less susceptible to MEV?</li> <li>Have we exhausted our list of possible attacks to our oracle systems and audited the code to invalidate them?</li> <li>Are there any circuit-breakers in place to prevent attackers from using manipulated prices?</li> </ul> <p>Stay tuned for Part II.</p> <p>– Alex Perez (reentrant)</p>]]></content><author><name></name></author><summary type="html"><![CDATA[What could go wrong when using trusted price feeds?]]></summary></entry><entry><title type="html">Testing the zkSync Era bootloader</title><link href="https://0xreentrant.github.io/blog/2024/testing-zksync-bootloader/" rel="alternate" type="text/html" title="Testing the zkSync Era bootloader"/><published>2024-02-08T00:00:00+00:00</published><updated>2024-02-08T00:00:00+00:00</updated><id>https://0xreentrant.github.io/blog/2024/testing-zksync-bootloader</id><content type="html" xml:base="https://0xreentrant.github.io/blog/2024/testing-zksync-bootloader/"><![CDATA[<blockquote> <p>NOTE: This was performed during the the last week of the Code4rena contest. While the time constraints prevented us from fully completing the endeavor, we plan to follow up post-contest.</p> </blockquote> <p>Remediations are included at the start of this document for pragmatic readers, and what follows is an analysis of the tooling available for the bootloader to be tested during an audit.</p> <p>To motivate this exploration, testing the bootloader was done with the intent of embodying the persona of a new hire attempting to build a testing suite for a niche aspect of the zkSync system. While the original intention was to build a fully functional test suite, the time allotted was too short to fully implement this vision.</p> <h2 id="remediations">Remediations</h2> <p>At the end of all this time, several suggestions were considered for the Matter Labs team to address:</p> <ol> <li>Provide an accessible, easy-to-update test suite, for the bootloader, to exercise both typical and edge-case transactions</li> <li>Add easy-to-access logging capability for further development, and auditing, of the bootloader</li> <li>Allow for accessible exploration of the bootloader memory throughout the execution of the bootloader</li> </ol> <h3 id="possible-test-suite">Possible test suite</h3> <p>For testing the bootloader, many kinds of scenarios can be formulated. The general structure of the scenarios is the execution of batches. In the the case that a batch contains a multitude of transactions, there is possibility of the state machine - that is implied by the bootloader’s code graph and memory - could provide opportunities for the invariants of the system to be violated.</p> <p>It would be valuable to create tests that exercise the bootloader in manners that demonstrate the invariants hold. High-level descriptions of invariants to test against attacks would be:</p> <ul> <li>escalate transaction type to privileged upgrade</li> <li>premature batch closure</li> <li>skipped transactions</li> <li>update batch data after closing</li> <li>incorrect gas calculations</li> <li>wrong tx.origin, msg.sender generated</li> <li>priorityQueue reordering</li> <li>general overwrite transaction data within batch</li> </ul> <h3 id="logging-capability">Logging capability</h3> <p>Put simply, providing easily accessible logging to the system through the test node would make exploration, development, and refactoring of the bootloader code a smoother process.</p> <h3 id="exploring-bootloader-memory">Exploring bootloader memory</h3> <p>Being able to peek into the memory of a running bootloader would be a powerful device. Possible methods could be - with no attempt to rank how difficult it would be to implement:</p> <ol> <li>Binary memory dumps: dump memory to files during execution so that a hex editor can be used to explore the data. Possible options could be to dump before or after each transaction, after a timeout, at every state change, etc.</li> <li>Provide a hook/file/endpoint for an external debugger to connect to: the canonical example is the Chrome webtools, which famously can connect to an external host to debug process on other devices. Likely there could be challenges in the control of the test node, pausing and resuming operation</li> <li>Include an internal debugger</li> </ol> <h1 id="analyzing-bootloader-tooling">Analyzing bootloader tooling</h1> <h2 id="assessing-testing-criteria">Assessing testing criteria</h2> <p>A survey of the provided codebase was made for any files related to the operation of the bootloader internals. No testing suites were found to satisfy that criteria.</p> <p>While examining the code of the bootloader itself, it was clear that the structure of this subsystem was unsuited to run-of-the-mill testing. This typically involves interacting with explicit interfaces defined in the code, including externally visible functions and constructors. What was found is that the bootloader operates on memory loaded by the zkSync Era EVM (which we’ll call “zkEVM” at times throughout this document). Additionally, there were no externally-visible functions, and no constructor.</p> <blockquote> <p>NOTE: In the scope of the zkSync Era codebase, it is clear that the bootloader was coded in Yul to take advantage of the increased control over the resulting compiled code’s performance. The consequence here is that, for Yul, the limited tooling in the wider EVM-based ecosystem leaves a lot to be desired in terms of developer experience, including the ability to test and benchmark Yul codebases.</p> </blockquote> <p>At this point, there were two major and relatively obvious paths that could be taken:</p> <ol> <li>Existing tools could be used to load and manipulate the bootloader memory and its environment</li> <li>The bootloader could be modified to provide external interfaces and a constructor to be used in popular testing frameworks</li> </ol> <p>It was decided that controlling the execution environment would be the best bet. The main factors were:</p> <ul> <li>controlling the memory to the granularity required by the bootloader would require brittle and difficult-to-maintain, parallel data structures between the zkEVM and test suite</li> <li>modifying the code changed the attack surface compared to the original implementation</li> <li>any modifications would likely change the memory outlay and performance characteristics of the original implementation</li> </ul> <h3 id="criteria-for-testing-the-bootloader">Criteria for testing the bootloader</h3> <p>During this time, the bootloader code itself was being analyzed for possible attack vectors. As a result, a handful of criteria were surfaced that could help explore these attacks:</p> <ol> <li>Many transactions would need to be available to load into memory to explore execution paths in the case memory segregation was compromised</li> <li>Full control over each transaction was necessary to explore cases where invariants across the zkEVM and bootloader execution were violated</li> <li>Logging and exploring the memory space was key</li> </ol> <h2 id="exploring-tooling-options">Exploring tooling options</h2> <p>Initially the in-scope, zkSync Era EVM code was explored to be used for loading the bootloader and constructing its memory. The understanding was that the zkEVM already had data structures and interfaces available that would make loading arbitrary transactions into the bootloader’s memory simple.</p> <p>While the code was available to explore, it was determined that the necessary “plumbing” to quickly get a proof-of-concept would take more time to understand and modify than was available. After discussing possibilities with the C4 sponsors, it was discovered that there was in fact a “test node” in development (era_test_node) that could provide a minimal environment for running the bootloader against individual transactions. This was quickly determined to be useful, and simple entry points and data structures were identified for controlling the bootloader memory:</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// matter-labs/era-test-node, src/node.rs</span>
<span class="mi">324</span><span class="p">:</span>    <span class="k">if</span> <span class="o">!</span><span class="n">transactions_to_replay</span><span class="nf">.is_empty</span><span class="p">()</span> <span class="p">{</span>
<span class="mi">325</span><span class="p">:</span>        <span class="k">let</span> <span class="n">_</span> <span class="o">=</span> <span class="n">node</span><span class="nf">.apply_txs</span><span class="p">(</span><span class="n">transactions_to_replay</span><span class="p">);</span>
<span class="mi">326</span><span class="p">:</span>    <span class="p">}</span>
</code></pre></div></div> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// matter-labs/era-test-node, src/node.rs</span>
<span class="mi">1204</span><span class="p">:</span> <span class="k">pub</span> <span class="k">fn</span> <span class="nf">run_l2_tx_inner</span><span class="p">(</span>
<span class="o">...</span> 
<span class="mi">1245</span><span class="p">:</span>         <span class="k">let</span> <span class="n">tx</span><span class="p">:</span> <span class="n">Transaction</span> <span class="o">=</span> <span class="n">l2_tx</span><span class="nf">.clone</span><span class="p">()</span><span class="nf">.into</span><span class="p">();</span>
<span class="mi">1246</span><span class="p">:</span> 
<span class="mi">1247</span><span class="p">:</span>         <span class="n">vm</span><span class="nf">.push_transaction</span><span class="p">(</span><span class="n">tx</span><span class="p">);</span>
</code></pre></div></div> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// matter-labs/zksync-era, core/lib/types/src/l2/mod.rs</span>
<span class="mi">133</span><span class="p">:</span> <span class="k">pub</span> <span class="k">struct</span> <span class="n">L2Tx</span> <span class="p">{</span>
</code></pre></div></div> <h3 id="roadblocks---single-transaction-mode">Roadblocks - single transaction mode</h3> <p>During discussions with one of the sponsors, it was made clear that the zkEVM used with the test node was configured to only run the bootloader with a single transaction at a time. This would be a roadblock. Scanning the code, it was determined that the solution was to include an existing VM setting:</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// matter-labs/zksync-era, core/lib/multivm/src/interface/types/inputs/execution_mode.rs</span>
<span class="mi">8</span><span class="p">:</span>    <span class="nn">vm</span><span class="p">::</span><span class="nn">VmExecutionMode</span><span class="p">::</span><span class="n">Bootloader</span>
</code></pre></div></div> <h3 id="logging-woes">Logging woes</h3> <p>During the implementation of a rough proof-of-concept, it was made clear that there was no easy way to read the logs from the bootloader through the test node. The two suggestions from a sponsor were:</p> <ol> <li>Use the <code class="language-plaintext highlighter-rouge">log0</code> - <code class="language-plaintext highlighter-rouge">log4</code> events in Yul so logs could be caught by the test node.</li> <li>Send transactions to the <code class="language-plaintext highlighter-rouge">Console</code> system contract.</li> </ol> <p>For the first option, the output would be a series of hex-encoded values according to the event parameters. For the second option, the test node would output the logged strings using when run with the correct command-line setting. This would be the preferred option.</p> <p>Unfortunately, neither seemed to be a great option, since the existing <code class="language-plaintext highlighter-rouge">debugLog</code> calls in the existing bootloader would not work. A third option was to be forking the <code class="language-plaintext highlighter-rouge">zksync-era</code> crate that was imported into the project and adding <code class="language-plaintext highlighter-rouge">println!</code> calls for when the <code class="language-plaintext highlighter-rouge">debugLog</code> hook was triggered.</p> <h3 id="results">Results</h3> <p>While there wasn’t time to fully implement the plan, the intended plan of attack became:</p> <ol> <li>Add a command line setting through <code class="language-plaintext highlighter-rouge">clap</code> to support loading a JSON file with multiple transactions and their fields</li> <li>Parse the JSON with <code class="language-plaintext highlighter-rouge">serde</code> and load the data into <code class="language-plaintext highlighter-rouge">L2Tx</code> instances</li> <li>Fill <code class="language-plaintext highlighter-rouge">transactions_to_replay</code> with the data</li> <li>Switch the vm execution mode to <code class="language-plaintext highlighter-rouge">Bootloader</code> while this new command line setting is triggered</li> <li>Fork and update the <code class="language-plaintext highlighter-rouge">zksync-era</code> crate to output logs in the <code class="language-plaintext highlighter-rouge">debugLog</code> hook</li> </ol> <h4 id="diagrams">Diagrams:</h4> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/tx_failure_mode-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/tx_failure_mode-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/tx_failure_mode-1400.webp"/> <img src="/assets/img/tx_failure_mode.png" class="img-fluid" width="auto" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/bootloader_block_processing-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/bootloader_block_processing-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/bootloader_block_processing-1400.webp"/> <img src="/assets/img/bootloader_block_processing.png" class="img-fluid" width="auto" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/bootloader_init-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/bootloader_init-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/bootloader_init-1400.webp"/> <img src="/assets/img/bootloader_init.png" class="img-fluid" width="auto" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/core_contracts_diamonds-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/core_contracts_diamonds-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/core_contracts_diamonds-1400.webp"/> <img src="/assets/img/core_contracts_diamonds.png" class="img-fluid" width="auto" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure>]]></content><author><name></name></author><summary type="html"><![CDATA[What does it take to test the security of a blockchain's most important core smart-contract?]]></summary></entry><entry><title type="html">Don’t let mocks in your protocol tests fool you</title><link href="https://0xreentrant.github.io/blog/2023/mocks-fool-you/" rel="alternate" type="text/html" title="Don’t let mocks in your protocol tests fool you"/><published>2023-10-19T00:00:00+00:00</published><updated>2023-10-19T00:00:00+00:00</updated><id>https://0xreentrant.github.io/blog/2023/mocks-fool-you</id><content type="html" xml:base="https://0xreentrant.github.io/blog/2023/mocks-fool-you/"><![CDATA[<h1 id="dont-let-mocks-in-your-protocol-tests-fool-you">Don’t let mocks in your protocol tests fool you</h1> <blockquote> <p>Note: This article was written for web3 protocol developers. Security researchers will also get a little glimpse into techniques for testing protocols.</p> </blockquote> <p><em>Mocking expensive, slow, or complex-to-set-up components is a great way to make testing faster, cheaper, and simpler to leverage. What can happen though, is that the expectations of the mock can diverge from the expectations of the real-world object. When that happens, you can be oblivious to the fact your codebase does not, in fact, work, green checkmarks be damned.</em></p> <p><em>The biggest threat to developing a protocol is the mental model of the protocol within the mind of the developer. A flawed mental model happens from numerous sources, but today we’ll focus on a single one: the feeling of security that comes with passing tests</em></p> <blockquote> <p>Note: I’m using the definition of “mock” to be along the lines of how Martin Fowler uses it here: https://martinfowler.com/articles/mocksArentStubs.html</p> </blockquote> <p><strong>TL;DR</strong> If you want to skip to what kind of things you can do to prevent mocks from fooling you, jump to <a href="#how-can-I-ensure-our-mocks-are-correct">How can I ensure our mocks are correct?</a></p> <h2 id="our-case">Our case</h2> <p>Imagine getting green checkmarks on all your tests. You’ve gone ahead and built a suite to exercise the entire happy path of your codebase, and even some edge cases to boot. And even better: every test passed. It’s a good time to grab a beer or wine and take a little break, because next you’re going to discover something unsavory when you try to run through the deployed example.</p> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/all-tests-green-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/all-tests-green-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/all-tests-green-1400.webp"/> <img src="/assets/img/all-tests-green.png" class="img-fluid" width="auto" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <blockquote> <p>Note: Before you hire a firm or to audit your code, do make sure to fully deploy your code to a testnet with all 3rd-party contracts and features available. For example: testing cross-chain protocols</p> </blockquote> <p>Cutting to the chase, you’re going to “Oh no, what’s wrong, I coded this <em>perfectly</em> - all the tests pass!” And you’re going to feel so right, because your mental model was impeccable and your tests reflected that… <em>but your mocks fooled you</em>. Actually, it’s just a case of a “<a href="https://en.wikipedia.org/wiki/False_positives_and_false_negatives">false positive</a>” (lest we lose our last shred of sanity and <a href="https://psychcentral.com/health/why-do-we-anthropomorphize">anthropomorphize</a> our code). Green checks that don’t give confidence are the antithesis of any testing methodology, so let’s break down what to keep in mind.</p> <h2 id="mocks-have-tradeoffs">Mocks have tradeoffs</h2> <p>When we use mocks, we’re taking a stance. The two main ones I hear and have held are:</p> <ol> <li>Our dependencies are too expensive, slow, or complex to spin up each time we test (<em>fair!</em>)</li> <li>We want our tests to run quickly, and we can’t wait for each test iteration to fully pass or well lose out on momentum (<em>fair!</em>)</li> </ol> <h3 id="but-what-are-the-consequences">But what are the consequences?</h3> <p>These tradeoffs, again, are fair to make when the stakes are low, like:</p> <ul> <li>When you’re building the protocol, pre-launch</li> <li>When you’re adding to an existing protocol and need the flexibility to refactor highly-coupled parts of a system</li> <li>When you’re exploring how to implement a new system</li> </ul> <p>Etc.</p> <p>But in the case of running a web3, immutable, smart-contract-based, financial protocol the stakes are high. As protocol developers in a hyper-competitive environment with close to zero consequences for exploitation by psuedo-anonymous actors that include globally-sanctioned blackhats, more care must be taken before accepting real people’s assets. I’ll let our industry’s favorite rug-pull <a href="https://rekt.news/stake-rekt/">journalist</a> say it best:</p> <p>They say the house always wins. Not in crypto.</p> <h2 id="how-can-i-ensure-our-mocks-are-correct">How can I ensure our mocks are correct?</h2> <p>“But reentrant, we read the documentation front-to-back and everything is working just like they said!”</p> <p>I 100% get it: you’ve put in the work.</p> <p>But, what if:</p> <ul> <li>The documentation is wrong</li> <li>The implementation has changed</li> <li>You used the wrong flag for a key function while trying to get that last PR in at 3am Saturday morning</li> </ul> <p>Then things break.</p> <p>What do you do? Add <em>at least</em> one more step, especially before deploying your new protocol.</p> <ol> <li>Create “smoke-tests” - as in short, typically disposable scripts that call major 3rd-party components the same as the mocks would be called.</li> <li>Deploy on a fully-functional testnet and run manual tests for all major features.</li> <li>Build “forking tests” that fork a live network locally and test against it. Some dependencies may not work if they are off-chain.</li> <li>Build integration tests for all major features, deploy on a fully-functional testnet, and test against it.</li> </ol> <p>&lt; decision tree for determinnig when mocks fail &gt;</p> <h2 id="what-do-these-possibilities-look-like">What do these possibilities look like?</h2> <p>There’s nothing like a real environment to expose the brittleness of a test suite’s assumptions. While it might seem unnecessary “because it’s there in the code,” the unique case of web3 warrants the extra paranoia.</p> <h3 id="smoke-tests">Smoke tests</h3> <p>This one makes sense when your contracts interface with 3rd-party code. Each feature that touches a 3rd-party contract is either triggered in a script or run manually. If the feature breaks, but your mocking tests were all passing, there is an issue with your mock.</p> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/smoke_tests-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/smoke_tests-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/smoke_tests-1400.webp"/> <img src="/assets/img/smoke_tests.png" class="img-fluid" width="auto" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <p>For example: imagine you are a protocol developer lead that wants to test that each feature that is mocked works. You would:</p> <ol> <li>Identify all the features that touch 3rd-party code.</li> <li>Write a script to exercise the 3rd-party contract code for each relevant feature, according to how you expect the API of that code to work.</li> <li>Run your script.</li> <li>Make a note if something broke, and how it broke</li> </ol> <p>You will find that increased logging through events or console logs will be useful when creating your scripts.</p> <p>We won’t go much deeper on the subject of smoke tests in web3, but here’s a great article for learning more about smoke tests: https://www.edureka.co/blog/what-is-smoke-testing/</p> <h3 id="manual-testing-on-a-testnet">Manual testing on a testnet</h3> <p>This one is pretty obvious in operation. The goal here is to make sure every feature that interfaces with 3rd-party components has been run, along with some edge-cases that have been identified. That way you are exercising whatever assumptions your code is making about the interface of code you don’t control.</p> <p>The advantage to running these on an existing testnet is that any off-chain systems your preferred 3rd-party system uses will be more or less accessible. A downside would be the necessity of amassing gas tokens for the respective testnet.</p> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/manual-tests-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/manual-tests-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/manual-tests-1400.webp"/> <img src="/assets/img/manual-tests.png" class="img-fluid" width="auto" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <p>Similarly to running smoke tests, the point is to get an actual look at whether any assumptions encoded in the codebase, and your mocks, match the real-world requirements of any 3rd-party component.</p> <p>Doing this yourself:</p> <ol> <li>Identify all the features that touch 3rd-party code.</li> <li>Perform all the operations in your app to exercise the 3rd-party contract code for each relevant feature, according to how you expect the API of that code to work.</li> <li>Make a note if something broke, and how it broke</li> </ol> <p>If any of your mocking tests passed, but manual testing fails where your tests had mocks, then that’s an unmistakable sign something is broken in your codebase <em>and</em> tests.</p> <h3 id="forking-tests">Forking tests</h3> <p>When there is no need to monitor the results of any off-chain systems, you can fork any live chain and run a version of it locally for more control and execution speed. This also is advantageous for the off-chance that your 3rd-party of choice decides not to run a version on a testnet.</p> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/forking-tests-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/forking-tests-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/forking-tests-1400.webp"/> <img src="/assets/img/forking-tests.png" class="img-fluid" width="auto" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <p>Unlike the smoke tests and the manual tests, we are back to writing automated tests. We can use our existing testing suites, with the modification that now any mocked calls will instead call actual contracts hosted on the forked testnet. That way any assumptions that mocks encode will be instead tested against actual code.</p> <p>A disadvantage of this approach is that the tests themselves will likely take longer to run each cycle compared to the mocking tests. However, compared to smoke tests and manual testing, you’ll get the increased coverage and repeatability of automated testing along with the better assurance of correctness.</p> <h3 id="live-integration-tests">Live Integration Tests</h3> <p>The most intensive version of testing that would shake out any assumptions about 3rd-party interfaces in your codebase would be integration tests on a live testnet. All components are deployed to the testnet, mocks in tests are replaced with calls to actual on-chain resources, all tests run against the live testnet, and off-chain resources are available to monitor. You will need any testnet gas tokens for every run of the test suite.</p> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/integration-tests-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/integration-tests-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/integration-tests-1400.webp"/> <img src="/assets/img/integration-tests.png" class="img-fluid" width="auto" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <p>Every test will exercise live code as close to the final, real-world software environment possible. Any tests that fail here will give a lot of information about assumptions encoded in your codebase. Because there will be subtle differences between a local fork and an actual live chain, and the cost of running the test suite (in time and testnet gas) it will be helpful to monitor the results of the tests with other tools such as chain explorers like <a href="https://tenderly.co/">Tenderly</a> for delving into any edge cases that the other techniques did not uncover.</p> <h2 id="conclusion">Conclusion</h2> <p>We can see that mocks are helpful, but they have tradeoffs. To counter the possibility that mocks will give us false-positives, we can increase the assurances by running tests against actual 3rd-party code.</p> <p>In web3, it is imperative that all precautions are made to ensure real money isn’t lost to thefts or mishandling of digital currency. Test more, test often, and test comprehensively.</p>]]></content><author><name></name></author><summary type="html"><![CDATA[The biggest threat to developing a protocol is the mental model]]></summary></entry></feed>